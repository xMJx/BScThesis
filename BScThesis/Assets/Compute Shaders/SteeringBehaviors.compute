#pragma kernel CSMain

// Frame-specific
float DeltaTime;
float2 ThreatPosition;

// Constant at runtime
uint BoidCount;
float ThreatRange;
float NeighborhoodRange;
float MaxBoidSpeed;
float BoidMass;

// Force weights
float FleeWeight;
float CohesionWeight;
float SeparationWeight;
float AlignmentWeight;

struct BoidData
{
    float2 pos;
    float2 vel;
};

RWStructuredBuffer<BoidData> BoidDataBuffer;

float2 Seek(uint3 id, float2 targetPosition)
{
    float2 desiredVelocity = normalize(targetPosition - BoidDataBuffer[id.x].pos) * MaxBoidSpeed;
    return desiredVelocity - BoidDataBuffer[id.x].vel;
}

float2 Flee(uint3 id, float2 threatPosition)
{
    float2 toThreat = BoidDataBuffer[id.x].pos - threatPosition;
    if (length(toThreat) < ThreatRange)
    {
        float2 desiredVelocity = normalize(toThreat) * MaxBoidSpeed;
        return FleeWeight * (desiredVelocity - BoidDataBuffer[id.x].vel);
    }
    else
    {
        return float2(0, 0);
    }
}

float2 Flocking(uint3 id)
{
    float2 centerOfMass = { 0, 0 };
    float2 cohesionForce = { 0, 0 };

    float2 separationForce = { 0, 0 };
    float2 toAgent;
    
    float2 averageHeading = { 0, 0 };

    int NeighborCount = 0;

    for (uint i = 0; i < BoidCount; i++)
    {
        if (i != id.x)
        {
            if (length(BoidDataBuffer[i].pos - BoidDataBuffer[id.x].pos) <= NeighborhoodRange)
            {
                // cohesion
                centerOfMass += BoidDataBuffer[i].pos;

                // separation
                toAgent = BoidDataBuffer[id.x].pos - BoidDataBuffer[i].pos;
                separationForce += normalize(toAgent) / length(toAgent);
                
                // alignment
                if (BoidDataBuffer[i].vel.x != 0 || BoidDataBuffer[i].vel.y != 0)
                {
                    averageHeading += normalize(BoidDataBuffer[i].vel);
                }

                NeighborCount++;
            }
        }
    }

    if (NeighborCount > 0)
    {
        // cohesion
        centerOfMass /= NeighborCount;
        cohesionForce = Seek(id, centerOfMass);
        cohesionForce = normalize(cohesionForce);

        // alignment
        averageHeading /= NeighborCount;
    }
    
    if (BoidDataBuffer[id.x].vel.x != 0 || BoidDataBuffer[id.x].vel.y != 0)
    {
        averageHeading -= normalize(BoidDataBuffer[id.x].vel);
    }
    
    return CohesionWeight * cohesionForce + SeparationWeight * separationForce + AlignmentWeight * averageHeading;
}

float2 CalculateForce(uint3 id)
{
    float2 steeringForce = { 0, 0 };

    steeringForce += Flee(id, ThreatPosition);
    steeringForce += Flocking(id);

    return steeringForce;
}

void UpdateVelocity(uint3 id)
{
    float2 acceleration = CalculateForce(id) / BoidMass;
    BoidDataBuffer[id.x].vel += acceleration * DeltaTime;

    if (length(BoidDataBuffer[id.x].vel) > MaxBoidSpeed)
    {
        BoidDataBuffer[id.x].vel = normalize(BoidDataBuffer[id.x].vel) * MaxBoidSpeed;
    }
}

void Move(uint3 id)
{
    BoidDataBuffer[id.x].pos += BoidDataBuffer[id.x].vel * DeltaTime;
}

[numthreads(1, 1, 1)]
void CSMain(uint3 id : SV_DispatchThreadID)
{
    UpdateVelocity(id);
    Move(id);
}